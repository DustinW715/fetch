--I WANT TO DO MOST OF MY DATA TRANSFORMATIONS IN SQL, SO I AM SETTING UP STAGING TABLES ("T_" = TEMP TABLE)
--ULTIMATELY THESE TEMP TABLES ARE GOING TO SERVE A PURPOSE TOWARDS THE END WHEN I'M VALIDATING THE INPUTS.
--WHEN I'M DONE I SHOULD BE ABLE TO BUILD SOME CROSS JOINS THAT ILL TELL ME IF I'M MISSING SOMETHING OR IF 
--SOME DATA ELEMENT HAS BEEN OBSCURED.  BY DEFAULTING ALL DATA ELEMENTS TO 
--VARCAR I CAN BETTER INSURE THAT I DIDN'T CREATE AN ISSUE BY PRE-PROCESSING THE TRANSFORMATIONS IN PYTHON.
--THIS SHOULD CREATE A PURE EXTRACT THAT EXACTLY MATCHES WHAT IS IN THE BASE DATA FILES.
--NOTE: MY HOME MACHINE IS RUNNING SQL SERVER.  SOME OF THE FUNCTIONS I'M USING MAY BE DIFFERENT THAN OTHER PLATFORMS


--STAGING TABLES 
CREATE TABLE t_transactions (
    RECEIPT_ID VARCHAR(255),  
    PURCHASE_DATE VARCHAR(255), 
    SCAN_DATE VARCHAR(255), 
    STORE_NAME VARCHAR(255),  
    USER_ID VARCHAR(255),  
    BARCODE VARCHAR(255),  
    FINAL_QUANTITY VARCHAR(255),  
    FINAL_SALE VARCHAR(255) 
);


CREATE TABLE t_products (
	CATEGORY_1	VARCHAR(255),
	CATEGORY_2	VARCHAR(255),
	CATEGORY_3	VARCHAR(255),
	CATEGORY_4	VARCHAR(255),
	MANUFACTURER VARCHAR(255),	
	BRAND VARCHAR(255),
	BARCODE VARCHAR(255)
);

CREATE TABLE t_users (
	ID	VARCHAR(255),
	CREATED_DATE VARCHAR(255),	
	BIRTH_DATE VARCHAR(255),	
	STATE VARCHAR(255),	
	LANGUAGE VARCHAR(255),	
	GENDER VARCHAR(255)
);

--RUN STEPS IN JUPYTER


--FINAL/TARGET TABLES BASED ON THE DIAGRAM IN THE ASSIGNMENT WITH THE CORRECT COLUMN TYPE DEFINITIONS
--THESE TABLES WILL BE THE SOURCE OF ANALYSIS/REPORTING
CREATE TABLE TRANSACTIONS_EV (  --ADDING EV AS A SUFFIX FOR CLARITY TO ANYONE ELSE THAT MAY NEED TO USE THE TABLE.  EV = EVENT TABLE
    RECEIPT_ID VARCHAR(255),
    PURCHASE_DATE DATETIME,
    SCAN_DATE DATETIMEOFFSET,
    STORE_NAME VARCHAR(255),
    USER_ID VARCHAR(255),
    BARCODE BIGINT NULL,
    FINAL_QUANTITY DECIMAL(18,2) NULL,
    FINAL_SALE DECIMAL(18,2) NULL
);


CREATE TABLE USERS_D (  --ADDING D AS A SUFFIX FOR CLARITY TO ANYONE ELSE THAT MAY NEED TO USE THE TABLE.  D = DIMENSION TABLE
    ID VARCHAR(255),
    CREATED_DATE DATETIMEOFFSET,
    BIRTH_DATE DATETIMEOFFSET,
    STATE VARCHAR(50),
    LANGUAGE VARCHAR(50),
	GENDER VARCHAR(25)
);

DROP TABLE PRODUCTS_D;

CREATE TABLE PRODUCTS_D (
BARCODE BIGINT,
CATEGORY_1 VARCHAR(255),
CATEGORY_2 VARCHAR(255),
CATEGORY_3 VARCHAR(255),
CATEGORY_4 VARCHAR(255),
MANUFACTURER VARCHAR(255),
BRAND VARCHAR(255)
);



--VALIDATE THAT THE DATA HAS BEEN IMPORTED COMPLETELY, BY COMPARING THE COUNTS FROM THE DATAFRAMES IN PYTHON (EXPECTED = PYTHON RESULTS)
SELECT COUNT(1) FROM T_TRANSACTIONS;  --RESULT: 50000, EXPECTED: 50000  --OK
SELECT COUNT(1) FROM T_PRODUCTS; --RESULT: 845552, EXPECTED: 845552  --OK
SELECT COUNT(1) FROM T_USERS; --RESULT: 100000, EXPECTED: 100000  --OK

SELECT * FROM T_TRANSACTIONS;


--NOW LOAD IT INTO THE FINAL TABLES USING THE STANDARDIZED COLUMN TYPES

SELECT * FROM T_TRANSACTIONS --SCAN DATE IS A TIMESTAMP AND INCLUDES UTC, SOME BARCODES ARE <NA>, SOME ARE -1
SELECT * FROM T_TRANSACTIONS WHERE RECEIPT_ID = 'dccc1e04-aef8-4ab0-adad-7fa41cd54125'  --QUANTITY STORED AS DECIMAL AND SOME QUANTITIES ARE NON-INTEGER

--FIGURING OUT WHAT OPTIONS OTHER THAN NUMERIC ARE IN THE DATASET, INCORPORATING SOME OF THE OPTIONS I NOTICED ABOVE
SELECT DISTINCT CASE WHEN BARCODE = '-1' THEN '-1' ELSE CASE WHEN ISNUMERIC(BARCODE) = 1 THEN 'VALID BARCODE' ELSE BARCODE END END AS BARCODE_TYPE FROM T_TRANSACTIONS A  --HAS <NA> RECORDS

--MAKE SURE CONVERSION WORKS
SELECT CASE WHEN ISNUMERIC(BARCODE) = 1 THEN CONVERT(BIGINT, A.BARCODE) ELSE -999 END  AS BARCODE FROM T_TRANSACTIONS A

--LOAD TARGET TABLE--------------------------

INSERT INTO TRANSACTIONS_EV
    SELECT RECEIPT_ID, 
	CAST(PURCHASE_DATE AS DATETIME) AS PURCHASE_DATE, --CONVERT TO DATETIME
	CAST(SCAN_DATE AS DATETIMEOFFSET) AS SCAN_DATE,   --CONVERT TO DATETIMEOFFSET FOR UTC
	STORE_NAME, 
	USER_ID,
		CASE WHEN ISNUMERIC(BARCODE) = 1 THEN CONVERT(BIGINT, A.BARCODE) ELSE -999 END AS BARCODE,
	CASE WHEN ISNUMERIC(FINAL_QUANTITY) = 1 THEN CONVERT(DECIMAL(18,2), FINAL_QUANTITY) ELSE NULL END AS FINAL_QUANTITY,
	CASE WHEN ISNUMERIC(FINAL_SALE) = 1 THEN CONVERT(DECIMAL(18,2), FINAL_SALE) ELSE NULL END AS FINAL_SALE
    FROM T_TRANSACTIONS a --50000 ROWS = OK

--CHECK TRANSACTIONS LOADED EVERYTHING PROPERLY
SELECT COUNT(1) AS RECORD_CNT,
	 COUNT(DISTINCT RECEIPT_ID) AS RECEIPT_CNT,
	 COUNT(DISTINCT PURCHASE_DATE) AS PURCHASE_DT_CNT, 
	 COUNT(DISTINCT SCAN_DATE) AS SCAN_DT_CNT, 
	 COUNT(DISTINCT STORE_NAME) AS STORE_NAME_CNT, 
	 COUNT(DISTINCT USER_ID) AS USER_ID_CNT,
	 COUNT(DISTINCT BARCODE) AS BARCODE_CNT FROM T_TRANSACTIONS;

--50000	24440	89	24440	954	17694	11028
--COMPARED TO 
SELECT COUNT(1) AS RECORD_CNT,
	 COUNT(DISTINCT RECEIPT_ID) AS RECEIPT_CNT,
	 COUNT(DISTINCT PURCHASE_DATE) AS PURCHASE_DT_CNT, 
	 COUNT(DISTINCT SCAN_DATE) AS SCAN_DT_CNT, 
	 COUNT(DISTINCT STORE_NAME) AS STORE_NAME_CNT, 
	 COUNT(DISTINCT USER_ID) AS USER_ID_CNT,
	 COUNT(DISTINCT BARCODE) AS BARCODE_CNT FROM TRANSACTIONS_EV;
--EVERYTHING MATCHES
--50000	24440	89	24440	954	17694	11028


--I NOTICED A LOT OF NULLS IN FINAL QUANTITY AND FINAL SALE, SO WANT TO INVESTIGATE THAT
Select count(1) from transactions_ev where final_quantity is null  --12500
select count(1) from transactions_ev where final_sale is null --12500

--THE FACT THAT THE COUNT IS EXACTLY THE SAME FOR MISSING QUANTITY AND MISSING SALES MAKES ME BELIEVE THERE MUST BE SOME RECORDS THAT ARE SPLIT IN 2


Select * from transactions_ev where final_quantity is null or final_sale is null order by user_id, purchase_date, scan_date

select * from transactions_ev where final_quantity is null or final_sale is null order by store_name, barcode

Select count(distinct receipt_id) from transactions_ev where final_quantity is null or final_sale is null --24440 there are some extra records that could be split

--JOIN THE SPLIT RECORDS BASED ON RECEIPT ID AND BARCODE-------------------------
select a.receipt_id, a.purchase_date, a.scan_date, a.store_name, a.user_id, a.barcode, a.final_quantity, b.final_sale 
from transactions_ev a inner join transactions_ev b ON a.receipt_id = b.receipt_id and a.barcode = b.barcode
where a.final_sale is null and b.final_quantity is null

--HERES ANOTHER ONE I FOUND THAT WORKED THAT I'M STILL RELATIVELY CONFIDENT IN (SAME STORE, SAME USER, SAME DATE)
select a.receipt_id, a.purchase_date, a.scan_date, a.store_name, a.user_id, a.barcode, a.final_quantity, b.final_sale 
 from transactions_ev a inner join transactions_ev b ON a.user_id = b.user_id and a.store_name = b.store_name and a.purchase_date = b.purchase_date
where a.final_sale is null and b.final_quantity is null and a.receipt_id != b.receipt_id order by a.user_id, a.store_name

--NOTE:  I TRIED A COUPLE OTHER VARIATIONS, THAT DON'T INCLUDE USER, BUT WITHOUT SOME ADDITIONAL DETAILS I'M NOT CONFIDENT TO MAKE THOSE MATCHES
--WOULD BE HELPFUL IF THE USERS TABLE HAD SOME ADDITIONAL DATA TO TRY AND SEE IF PEOPLE ARE CAPABLE OF HAVING MORE THAN 1 USER_ID ASSOCIATED TO THEM
--ALSO, IF THE PRODUCT TABLE WERE COMPLETE I COULD POTENTIALLY DO SOME ADDITIONAL MATCHING WITH BARCODE LINKING TO SAME PRODUCTS

--NOW THAT I'VE FOUND SOME ADDITIONAL MATCHES I NEED TO APPLY IT TO THE DATASET.  FIRST, I'LL SAVE THE MATCHES TO A SEPARATE TABLE, THEN I'LL UPDATE THE PRIMARY TABLE
DROP TABLE DELETE_TRANSACTIONS;

CREATE TABLE DELETE_TRANSACTIONS (  --ADDING EV AS A SUFFIX FOR CLARITY TO ANYONE ELSE THAT MAY NEED TO USE THE TABLE.  EV = EVENT TABLE
    RECEIPT_ID VARCHAR(255),
	RECEIPT_ID2 VARCHAR(255),
    PURCHASE_DATE DATETIME,
    SCAN_DATE DATETIMEOFFSET,
	SCAN_DATE2 DATETIMEOFFSET,
    STORE_NAME VARCHAR(255),
    USER_ID VARCHAR(255),
    BARCODE BIGINT NULL,
	BARCODE2 BIGINT NULL,
    FINAL_QUANTITY DECIMAL(18,2) NULL,
    FINAL_SALE DECIMAL(18,2) NULL
);

TRUNCATE TABLE DELETE_TRANSACTIONS

INSERT INTO DELETE_TRANSACTIONS 
SELECT * FROM (
select a.receipt_id, b.receipt_id as receipt2, a.purchase_date, a.scan_date, b.scan_date as scan_date2, a.store_name, a.user_id, a.barcode, b.barcode as barcode2, a.final_quantity, b.final_sale 
from transactions_ev a inner join transactions_ev b ON a.receipt_id = b.receipt_id and a.barcode = b.barcode and a.store_name = b.store_name
where a.final_sale is null and b.final_quantity is null
UNION
select a.receipt_id, b.receipt_id as receipt2, a.purchase_date, a.scan_date, b.scan_date as scan_date2,  a.store_name, a.user_id, a.barcode, b.barcode as barcode2, a.final_quantity, b.final_sale 
 from transactions_ev a inner join transactions_ev b ON a.user_id = b.user_id and a.store_name = b.store_name and a.purchase_date = b.purchase_date
where a.final_sale is null and b.final_quantity is null and a.receipt_id != b.receipt_id) x  --249 records

select * from transactions_ev where receipt_id = '007d3232-3990-497f-a081-549e9e7a478b'




select sum(a.final_quantity), sum(a.final_sale) from transactions_ev a left join delete_transactions b 
ON ((a.scan_date = b.scan_date and a.receipt_id = b.receipt_id and a.barcode = b.barcode and a.purchase_date = b.purchase_date) 
or (a.receipt_id = b.RECEIPT_ID2 and a.scan_date = b.scan_date2 and a.barcode = b.barcode2)) and a.user_id = b.user_id
where (a.FINAL_QUANTITY is null or a.final_sale is null) and (b.receipt_id is not null or b.receipt_id2 is not null) 



--delete extra rows for the matches that i found
DELETE a
FROM transactions_ev a
LEFT JOIN delete_transactions b 
ON ((a.scan_date = b.scan_date AND a.receipt_id = b.receipt_id AND a.barcode = b.barcode AND a.purchase_date = b.purchase_date) 
    OR (a.receipt_id = b.RECEIPT_ID2 AND a.scan_date = b.scan_date2 AND a.barcode = b.barcode2))
AND a.user_id = b.user_id
WHERE 
    (a.FINAL_QUANTITY IS NULL OR a.FINAL_SALE IS NULL) 
    AND (b.receipt_id IS NOT NULL OR b.RECEIPT_ID2 IS NOT NULL);

--ADD THE MERGED RECORDS BACK TO THE ORIGINAL TRANSACTION TABLE
INSERT INTO TRANSACTIONS_EV SELECT RECEIPT_ID, PURCHASE_DATE, SCAN_DATE, STORE_NAME, USER_ID, BARCODE, FINAL_QUANTITY, FINAL_SALE
FROM DELETE_TRANSACTIONS



--SCRATCH SPACE---------------
SELECT * FROM transactions_ev a where a.final_quantity is null or a.final_sale is null

select * from products_d where barcode IN(34000291328,16000124790, 28400589277) --NOT THE SAME PRODUCT

SELECT * FROM PRODUCTS_D WHERE BARCODE in(6970707749356,37600013048, 812446030011,850031990005)  --ONLY ONE OF THES PRODUCTS IS AVAILABLE ON THE TABLE


Select * from users_d where id IN('634b066fda0f5faf4762e09a','5ef661c703e926141cdde3c4')


-----------------CONVERT USERS TABLE ----------------------
SELECT * FROM T_USERS;  --LOTS OF GENDER CHOICES, BIRTHDATE IS A TIMESTAMP WHICH IS WEIRD, OTHER THAN THAT MAIN ISSUE IS NULL VALUES
SELECT COUNT(1), COUNT(DISTINCT ID) FROM T_USERS  --USER IDS ARE UNIQUE IN THIS TABLE


INSERT INTO USERS_D
SELECT ID, 
CAST (CREATED_DATE AS DATETIMEOFFSET) AS CREATED_DATE,
 --ELIMINATING TIMESTAMP FOR BIRTHDAY TO HELP FUTURE INDEX / REDUCE CARDINALITY --TIME OF DAY DOESN'T SEEM USEFUL FOR BIRTHDAY
CAST (CASE WHEN LEN(BIRTH_DATE) > 0 THEN SUBSTRING(BIRTH_DATE,1,10) ELSE '2099-12-31' END AS DATETIME) AS BIRTH_DATE,  --COULD HAVE USED NULLIF AGAIN INSTEAD OF LEN()
STATE, LANGUAGE, GENDER FROM T_USERS;  --100000 RECORDS = OK

SELECT  COUNT(DISTINCT ID), COUNT(DISTINCT CREATED_DATE), COUNT(DISTINCT BIRTH_DATE), COUNT(DISTINCT LANGUAGE), COUNT(DISTINCT GENDER) FROM T_USERS;
--100000	99942	54722	3	12
--VS--
SELECT  COUNT(DISTINCT ID), COUNT(DISTINCT CREATED_DATE), COUNT(DISTINCT BIRTH_DATE), COUNT(DISTINCT LANGUAGE), COUNT(DISTINCT GENDER) FROM USERS_D;
--100000	99942	21820	3	12
--LOOKS GOOD CONSIDERING I TRUNCATED THE BIRTHDAY TO THE DATE LEVEL


--IT JUST OCCURED TO ME THAT I COULD POSSIBLY USE THE USERS TABLE TO FIGURE OUT MORE OF THOSE NULL VALUES IN THE TRANSACTIONS TABLE
--USING THE BELOW QUERY, I THINK IT SEEMS PLAUSABLE THAT SOME INDIVIDUALS MAY HAVE MORE THAN ONE USER ID
--I ATTEMPTED TO MATCH TRANSACTIONS FROM THOSE USERS, TO SEE IF IT MIGHT MAKE SENSE.
--THIS QUERY DOES RETURN RESULTS, BUT I'M NOT PURSUING IT FURTHER, BECAUSE THERE AREN'T ENOUGH DATA ELEMENTS FOR ME TO FEEL CONFIDENT IN MERGING THE RECORDS
--NOT ENOUGH DATA ELEMENTS = A MATCH ON BIRTH_DATE AND STATE ISN'T ENOUGH.  I LOOKED AT THE ORIGINAL TABLE ALSO WHICH INCLUDED TIMESTAMP IN BIRTHDAY
--IF I WERE TO PURSUE THIS FURTHER I WOULD NEED OTHER ATTRIBUTES SUCH AS USER ADDRESS, FIRST, LAST NAME, ETC....
SELECT * FROM TRANSACTIONS_EV WHERE USER_ID IN(SELECT DISTINCT ID FROM USERS_D A WHERE EXISTS
(SELECT BIRTH_DATE, STATE, COUNT(DISTINCT ID) FROM USERS_D WHERE BIRTH_DATE IS NOT NULL AND STATE IS NOT NULL
AND BIRTH_DATE = A.BIRTH_DATE
AND STATE = A.STATE GROUP BY BIRTH_DATE, STATE HAVING COUNT(1) > 1)) AND FINAL_QUANTITY IS NULL OR FINAL_SALE IS NULL ORDER BY STORE_NAME, SCAN_DATE


-----------------CONVERT PRODUCTS TABLE ----------------------
SELECT * FROM T_PRODUCTS;  --LOTS OF NULL VALUES, BARCODE STORED AS DECIMAL AGAIN

--CHECKING BARCODE USING SAME CODE I CHECKED TRANSACTIONS
SELECT DISTINCT CASE WHEN BARCODE = '-1' THEN '-1' ELSE CASE WHEN ISNUMERIC(BARCODE) = 1 THEN 'VALID BARCODE' ELSE BARCODE END END AS BARCODE_TYPE FROM T_PRODUCTS A  --HAS '' RECORDS

TRUNCATE TABLE PRODUCTS_D;
INSERT INTO PRODUCTS_D
SELECT DISTINCT --FIRST TRY I DIDN'T INCLUDE DISTINCT AND GOT SOME DUPLICATE RECORDS
CASE WHEN NULLIF(A.BARCODE,'') IS NULL THEN -1 ELSE CAST(CONVERT(DECIMAL(18,2), A.BARCODE) AS BIGINT) END AS BARCODE,  --PERSONAL PREFERENCE, KEY FIELD SHOULD BE TOWARDS FRONT OF TABLE
CATEGORY_1, CATEGORY_2, CATEGORY_3, CATEGORY_4, MANUFACTURER, BRAND FROM T_PRODUCTS A; --845552, WITH DISTINCT ON 845,337

--COMPARE THE TABLES
SELECT COUNT(DISTINCT BARCODE), COUNT(DISTINCT CATEGORY_1), COUNT(DISTINCT CATEGORY_2), COUNT(DISTINCT CATEGORY_3), COUNT(DISTINCT CATEGORY_4),
COUNT(DISTINCT MANUFACTURER), COUNT(DISTINCT BRAND) FROM T_PRODUCTS;
--841343	28	122	345	128	4355	8122

--VS--
SELECT count(1), COUNT(DISTINCT BARCODE), COUNT(DISTINCT CATEGORY_1), COUNT(DISTINCT CATEGORY_2), COUNT(DISTINCT CATEGORY_3), COUNT(DISTINCT CATEGORY_4),
COUNT(DISTINCT MANUFACTURER), COUNT(DISTINCT BRAND) FROM PRODUCTS_D;
--841343	28	122	345	128	4355	8122

--SO THE STAGING AND TARGET TABLE MATCH EACH OTHER HERE, BUT THE COUNT OF DISTINCT BARCODES IS LESS THAN THE TOTAL RECORD COUNT WHICH MEANS THERE ARE SOME DUPLICATES

--LOOK AT DUPLICATES---

SELECT BARCODE, COUNT(1) FROM PRODUCTS_D GROUP BY BARCODE HAVING COUNT(1) > 1  --184 NUMERIC BARCODES ARE IN THERE/DUPLICATED, ALSO 4025 EMPTY BARCODES
																			   --SECOND PASS WITH DISTINCT = 27 NUMERIC DUPLICATES, 3968 EMPTY BARCODES

SELECT * FROM PRODUCTS_D A WHERE BARCODE IN(SELECT BARCODE FROM PRODUCTS_D GROUP BY BARCODE HAVING COUNT(1) > 1) AND BARCODE > 0 ORDER BY BARCODE

--SINCE THERE ARE ONLY 54 DIFFERENCES, I'M GOING TO STORE THE DUPLICATES IN A SEPARATE TABLE, DO SOME CLEANUP, THEN APPLY THE CHANGES TO THE MAIN TABLE.

--NOTE: THE REASON I KEEP CREATING A TABLE FIRST AND THEN INSERTING IS THAT THE VERSION OF SQL I'M RUNNING REQUIRES IT
--IN MANY OTHER SQL DIALECTS I WOULD HAPPILY DO A CREATE TABLE AS SELECT ETC...
CREATE TABLE DELETE_PRODUCTS (  
BARCODE BIGINT,
CATEGORY_1 VARCHAR(255),
CATEGORY_2 VARCHAR(255),
CATEGORY_3 VARCHAR(255),
CATEGORY_4 VARCHAR(255),
MANUFACTURER VARCHAR(255),
BRAND VARCHAR(255)
);

INSERT INTO DELETE_PRODUCTS SELECT * FROM PRODUCTS_D A WHERE BARCODE IN(SELECT BARCODE FROM PRODUCTS_D 
GROUP BY BARCODE HAVING COUNT(1) > 1) AND BARCODE > 0 ORDER BY BARCODE

--FROM HERE I'M MANUALLY OPENING THE DELETE_PRODUCTS_TABLE AND REMOVING THOSE RECORDS THAT I WANT TO KEEP IN THE FINAL TABLE.  29 ROWS TO DELETE.
--TAKING MY BEST GUESSES ON SOME OF THESE, NOT SURE I'LL GET ALL OF THEM RIGHT, BUT THE CHANGES I'VE MADE ARE STORED IN A SEPARATE TABLE NOW, SO
--I CAN ROLL BACK IF I NEED TO.
DELETE P
FROM PRODUCTS_D P
INNER JOIN DELETE_PRODUCTS D
ON P.BARCODE = D.BARCODE
AND P.CATEGORY_1 = D.CATEGORY_1
AND P.CATEGORY_2 = D.CATEGORY_2
AND P.CATEGORY_3 = D.CATEGORY_3
AND P.CATEGORY_4 = D.CATEGORY_4
AND P.MANUFACTURER = D.MANUFACTURER
AND P.BRAND = D.BRAND;  --DUPLICATES REMOVED

--NOW THAT THE 3 TARGET/PROD TABLES ARE LOADED I'M GOING TO COMPARE THEM FOR COMPLETENESS

SELECT COUNT(DISTINCT USER_ID) FROM TRANSACTIONS_EV A WHERE NOT EXISTS(SELECT 1 FROM USERS_D WHERE ID = A.USER_ID) 
--17,603 USERS EXIST ON THE TRANSACTION TABLE THAT AREN'T IN THE USERS TABLE

SELECT * FROM TRANSACTIONS_EV A WHERE NOT EXISTS(SELECT 1 FROM USERS_D WHERE ID = A.USER_ID) 

--JUST DOUBLE CHECKING
SELECT * FROM USERS_D WHERE ID = '53ce6404e4b0459d949f33e9' --CONFIRMED: DOES NOT EXIST

--CURIOUS IF THIS IS RELATED TO A SPECIFIC DATE RANGE
SELECT MIN(PURCHASE_DATE), MAX(PURCHASE_DATE) FROM TRANSACTIONS_EV A WHERE NOT EXISTS(SELECT 1 FROM USERS_D WHERE ID = A.USER_ID)  
--THERE ARE UNIDENTIFIED USERS AGAINST THE ENTIRE DATE RANGE.

--------PRODUCTS DIMENSION TABLE------

SELECT COUNT(DISTINCT BARCODE) FROM TRANSACTIONS_EV A WHERE NOT EXISTS(SELECT 1 FROM PRODUCTS_D WHERE BARCODE = A.BARCODE) 
--4465 PRODUCTS ON THE TRANSACTION TABLE THAT AREN'T IN THE PRODUCTS TABLE

SELECT * FROM TRANSACTIONS_EV A WHERE NOT EXISTS(SELECT 1 FROM PRODUCTS_D WHERE BARCODE = A.BARCODE) 

SELECT * FROM PRODUCTS_D WHERE BARCODE = 40100009299 --CONFIRMED: DOES NOT EXIST

--MISSING DATA IN THE DIMENSIONS TABLE ISN'T SOMETHING I CAN FIX WITHOUT SOME ADDITIONAL DATA.  I'LL BE SURE TO INCLUDE THESE REQUESTS IN THE EMAIL.
--FOR NOW, I HAVE A FEW OTHER THINGS THAT I WANT TO ADDRESS

UPDATE PRODUCTS_D SET MANUFACTURER = NULL WHERE MANUFACTURER LIKE '%PLACEHOL%' -- I DON'T THINK THE PLACEHOLDER MANUFACTURER ADDS ANY VALUE

UPDATE PRODUCTS_D
SET CATEGORY_1 = NULLIF(CATEGORY_1, ''),
    CATEGORY_2 = NULLIF(CATEGORY_2, ''),
    CATEGORY_3 = NULLIF(CATEGORY_3, ''),
    CATEGORY_4 = NULLIF(CATEGORY_4, ''),
	MANUFACTURER = NULLIF(MANUFACTURER, ''),
	BRAND = NULLIF(BRAND, '');  --DON'T LIKE THE '' VALUES. NULLS ARE EASIER TO DEAL WITH

UPDATE USERS_D
SET STATE = NULLIF(STATE,''),
	LANGUAGE = NULLIF(LANGUAGE,''),
	GENDER = NULLIF(GENDER,''),
	BIRTH_DATE = NULLIF(BIRTH_DATE,'');


----- BUILDING A COUPLE CROSS REFERENCE TABLES ----------------------------------------
-- I WANT TO BUILD SOME ADDITIONAL TABLES SO THAT WHEN I PULL THE DATA INTO TABLE SOME OF THE TRANSFORMATIONS ARE ALREADY COMPLETED.
-- THE REASON I'M DOING IT IN THE SQL AND NOT ALWAYS USING TABLEAUS ABILITY TO DO GROUPINGS AND CALCULATED FIELDS IS FOR TRACEABILITY
-- IF THE CLIENT WERE TO ASK FOR MORE DETAILS RELATED TO RECORD X ON THE DASHBOARD, I'D LIKELY HAVE TO BUILD SOME SORT OF MAPPING ANYWAY
-- SPECIFICALLY, I'D LIKE TO HANDLE GENDER, LANGUAGE, STATE, IN A CLEANER FASHION

--- STATE --------------------
	--AGAIN, THE APPROACH THAT I'M GOING TO TAKE IS TO BUILD A STATE TABLE TO USE IN MY QUERIES LATER.  SEEMS MORE EFFICIENT THAN A 50+ LINE CASE STATEMENT
	--I GOOGLED STATE CODES AND NAMES AND GOT A LIST FROM https://www.ssa.gov/international/coc-docs/states.html
	--AFTER PASTING THE LIST INTO EXCEL I USED EXCEL TO CREATE THE BELOW INSERT STATEMENT  
	--I WROTE THE TOP OF THE INSERT STATEMENT AND JUST ADDED ROWS TO DO = "('" & a3 & "','" & B3 & "'),"


CREATE TABLE STATE_D 
(STATE VARCHAR(10),
STATE_NAME VARCHAR(50)
)


INSERT INTO STATE_D (STATE, STATE_NAME)
VALUES
('AL', 'Alabama'),
('AK', 'Alaska'),
('AZ', 'Arizona'),
('AR', 'Arkansas'),
('CA', 'California'),
('CO', 'Colorado'),
('CT', 'Connecticut'),
('DE', 'Delaware'),
('FL', 'Florida'),
('GA', 'Georgia'),
('HI', 'Hawaii'),
('ID', 'Idaho'),
('IL', 'Illinois'),
('IN', 'Indiana'),
('IA', 'Iowa'),
('KS', 'Kansas'),
('KY', 'Kentucky'),
('LA', 'Louisiana'),
('ME', 'Maine'),
('MD', 'Maryland'),
('MA', 'Massachusetts'),
('MI', 'Michigan'),
('MN', 'Minnesota'),
('MS', 'Mississippi'),
('MO', 'Missouri'),
('MT', 'Montana'),
('NE', 'Nebraska'),
('NV', 'Nevada'),
('NH', 'New Hampshire'),
('NJ', 'New Jersey'),
('NM', 'New Mexico'),
('NY', 'New York'),
('NC', 'North Carolina'),
('ND', 'North Dakota'),
('OH', 'Ohio'),
('OK', 'Oklahoma'),
('OR', 'Oregon'),
('PA', 'Pennsylvania'),
('RI', 'Rhode Island'),
('SC', 'South Carolina'),
('SD', 'South Dakota'),
('TN', 'Tennessee'),
('TX', 'Texas'),
('UT', 'Utah'),
('VT', 'Vermont'),
('VA', 'Virginia'),
('WA', 'Washington'),
('WV', 'West Virginia'),
('WI', 'Wisconsin'),
('WY', 'Wyoming'),
('PR', 'Puerto Rico');

SELECT DISTINCT STATE FROM USERS_D WHERE STATE NOT IN(SELECT STATE FROM STATE_D)  --LOOKS LIKE I MISSED DC

INSERT INTO STATE_D (STATE, STATE_NAME) VALUES ('DC','Washington DC')  --IT'S THERE NOW

----- LANGUAGE -------------------
--THE CURRENT LANGUAGE FIELD ONLY INCLUDES LANGUAGE CODES, NOT THE ACTUAL NAME OF THE LANGUAGE
-- FOR USER READABILITY I'M BUILDING A SMALL DIMENSION TABLE THAT CONTAINS THE NORMAL NAMES OF THE LANGUAGES
--AGAIN, I COULD JUST AS EASILY DO THIS IN TABLEAU WITH AN ALIAS, BUT I LIKE THIS APPROACH IN CASE I NEED TO GO BACK INTO THE DATABASE

CREATE TABLE LANGUAGE_D
(LANGUAGE VARCHAR(25),
LANGUAGE_NORM VARCHAR(25)
)

INSERT INTO LANGUAGE_D (LANGUAGE) SELECT DISTINCT LANGUAGE FROM T_USERS a WHERE NOT EXISTS(SELECT 1 FROM LANGUAGE_D WHERE LANGUAGE = a.LANGUAGE)
-- I OPENED THE TABLE MANUALLY AND ADDED THE WORDS 'ENGLISH', 'SPANISH', AND 'NOT SPECIFIED' TO COLUMN 2 OF THE TABLE
-- EVEN THOUGH THE TABLE IS NEW/EMPTY I ADDED THE NOT EXISTS THINKING THAT IF I GET AN UPDATED DATASET IT WILL ADD ONLY NEW RECORDS WITHOUT DUPLICATING OLD ONES

------- GENDER --------------
SELECT DISTINCT GENDER FROM T_USERS;  --12 POSSIBILITIES FOR GENDER.

CREATE TABLE GENDER_D 
(GENDER VARCHAR(50),
 GENDER_NORM VARCHAR(50)  --NORM = NORMALIZED
)

INSERT INTO GENDER_D (GENDER) SELECT DISTINCT GENDER FROM T_USERS a WHERE NOT EXISTS(SELECT 1 FROM GENDER_D WHERE GENDER = a.GENDER);

--I FILLED IN THE GENDER_NORM COLUMN MANUALLY BY OPENING THE TABLE.  
--I SET IT UP TO ADD NEW RECORDS WITHOUT DUPLICATING EXISTING RECORDS IN CASE I GET AN UPDATED DATA SET

---------------------------------------------------------------------------------------------------------------
----------------------------------- BUILD QUERY FOR TABLEAU CONSUMPTION ---------------------------------------
---------------------------------------------------------------------------------------------------------------
--FIRST SOME INDEXES: SMALL TABLES SO PROBABLY DON'T EVEN NEED THEM.
CREATE UNIQUE INDEX USER_ID ON USERS_D(ID);
CREATE INDEX TXN_BARCODE ON TRANSACTIONS_EV(BARCODE);
CREATE INDEX TXN_RECEIPT ON TRANSACTIONS_EV(RECEIPT_ID);
CREATE INDEX TXN_DATE ON TRANSACTIONS_EV(PURCHASE_DATE);
CREATE INDEX PROD_BARCODE ON PRODUCTS_D(BARCODE);

UPDATE STATISTICS USERS_D;
UPDATE STATISTICS TRANSACTIONS_EV;
UPDATE STATISTICS PRODUCTS_D;

 

-- TABLEAU HAS THE CAPABILITY TO DO A LOT OF TRANSFORMATIONS AND JOINS NATIVELY
-- SOMETIMES I USE THEM, BUT IN THIS CASE I'M OPTING TO DO A LOT OF THE DATA IN A PREPROCESSING STEP IN SQL
-- I REALIZE THAT THE DATASET I WAS GIVEN IS ONLY RELATIVELY SMALL, BUT MAKING THE ASSUMPTION THAT THIS IS ONLY A SAMPLING OF DATA
-- TABLEAU CAN SOMETIMES PRESENT A USER WITH A SPINNING HOURGLASS WHILE IT GOES THROUGH THE PROCESS OF RUNNING CALCULATIONS AND JOINS ON LARGE DATASETS
-- PREPROCESSING THE DATA TAKES THE BURDEN AWAY FROM THE CLIENT SIDE OF THINGS

--THIS QUERY RETURNS ONE ROW FOR EVERY RECORDS IN THE TRANSACTION TABLE.
SELECT  TXN.RECEIPT_ID, TXN.PURCHASE_DATE, TXN.SCAN_DATE, TXN.STORE_NAME, TXN.USER_ID, 
PROD.MANUFACTURER, PROD.CATEGORY_1, PROD.CATEGORY_2, PROD.CATEGORY_3, PROD.CATEGORY_4, PROD.MANUFACTURER, PROD.BRAND,  
TXN.BARCODE, 
TXN.FINAL_QUANTITY AS ORIGINAL_QUANTITY, 
TXN.FINAL_SALE AS ORIGINAL_SALE,
USR.CREATED_DATE AS USER_CREATED_DATE, USR.BIRTH_DATE, USR.GENDER, USR.GENDER_ENTERED, USR.LANGUAGE_CODE, USR.STATE, USR.STATE_ABBR,
CASE WHEN  TXN.BARCODE < 0 THEN 'MISSING BARCODE ON TXN' 
	ELSE CASE WHEN PROD.BARCODE IS NULL THEN 'MISSING BARCODE ON PRODUCT' 
	ELSE 'BARCODE FOUND' END END AS BARCODE_STATUS,  --GONNA USE THIS TO HELP SHOW THE MISSING DATA RELATED TO PRODUCTS 
CASE WHEN USR.ID IS NULL THEN 'UNKNOWN USER' ELSE 'KNOWN USER' END AS USER_STATUS,  --THIS ONE IS TO SHOW THE LACK OF USER INFO ON THE SUPPLIED USER TABLE
CASE WHEN TXN.FINAL_SALE IS NULL THEN 'MISSING PRICE' ELSE 'OK' END AS SALES_STATUS,
CASE WHEN TXN.FINAL_QUANTITY IS NULL THEN 'MISSING QUANTITY' ELSE 'OK' END AS QUANTITY_STATUS
FROM TRANSACTIONS_EV TXN
LEFT OUTER JOIN PRODUCTS_D PROD ON NULLIF(TXN.BARCODE,-1) = PROD.BARCODE  -- ALREADY ESTABLISHED THAT SOME BARCODES DON'T EXIST IN PRODUCTS TABLE
LEFT OUTER JOIN (SELECT ID, CREATED_DATE, BIRTH_DATE, LANGUAGE_NORM AS LANGUAGE, A.LANGUAGE AS LANGUAGE_CODE, A.GENDER AS GENDER_ENTERED, 
				GENDER_NORM AS GENDER, STATE_NAME AS STATE, A.STATE AS STATE_ABBR FROM USERS_D A LEFT OUTER JOIN LANGUAGE_D B ON A.LANGUAGE = B.LANGUAGE
				LEFT OUTER JOIN GENDER_D C ON A.GENDER = C.GENDER LEFT OUTER JOIN STATE_D D ON A.STATE = D.STATE) USR ON TXN.USER_ID = USR.ID



Select * from transactions_ev order by barcode
















--------------------------EVERYTHING BELOW THIS SECTION IS JUST SCRATCH SPACE-------------------------------------------
--THINGS BELOW HERE ARE NOT ALWAYS IN A COHERENT ORDER, SOME OF THEM WERE OTHER PASSES THAT I TOOK AT EXAMINING THE DATA, NOTES ARE RANDOM




------------------------------------------------------------------------------------------
-------------------------- APPENDIX --------------
------------------------------------------------------------------------------------------
SELECT * from USERS_D

SELECT * FROM TRANSACTIONS_EV



SELECT round(sum(final_sale_corrected),2), round(sum(final_sale_corrected2),2) FROM (
SELECT 
    barcode, final_quantity, store_name, 
    COALESCE(NULLIF(final_sale, ''), AVG(CAST(NULLIF(final_sale, '') AS DECIMAL(18,2))) OVER (PARTITION BY barcode, store_name, nullif(final_quantity,''), substring(purchase_date,1,7))) AS final_sale_corrected,
	COALESCE(NULLIF(final_sale, ''), AVG(CAST(NULLIF(final_sale, '') AS DECIMAL(18,2))) OVER (PARTITION BY barcode, store_name, nullif(final_quantity,''))) AS final_sale_corrected2,
	COALESCE(NULLIF(final_quantity, ''), AVG(CAST(NULLIF(final_quantity, '') AS DECIMAL(18,2))) OVER (PARTITION BY barcode, store_name, substring(purchase_date,1,7), nullif(final_sale,''))) AS final_quantity_corrected
FROM t_transactions) a 


SELECT SUM(FINAL_SALE), SUM(UPDATED_SALE_AVG), SUM(UPDATED_SALE_MAX), SUM(UPDATED_SALE_MIN) FROM (
SELECT BARCODE, FINAL_SALE,
COALESCE(FINAL_SALE, AVG(FINAL_SALE) OVER (PARTITION BY BARCODE, STORE_NAME, FINAL_QUANTITY, FORMAT(PURCHASE_DATE, 'yyyy-MM'))) AS UPDATED_SALE_AVG,
COALESCE(FINAL_SALE, MAX(FINAL_SALE) OVER (PARTITION BY BARCODE, STORE_NAME, FINAL_QUANTITY, FORMAT(PURCHASE_DATE, 'yyyy-MM'))) AS UPDATED_SALE_MAX,
COALESCE(FINAL_SALE, MIN(FINAL_SALE) OVER (PARTITION BY BARCODE, STORE_NAME, FINAL_QUANTITY, FORMAT(PURCHASE_DATE, 'yyyy-MM'))) AS UPDATED_SALE_MIN
FROM TRANSACTIONS_EV) A

--171614.40	228172.016189	308575.64	221434.23




SELECT * FROM T_TRANSACTIONS





SELECT * FROM PRODUCTS_D WHERE MANUFACTURER IS NULL





SELECT * FROM T_TRANSACTIONS;
--BIGGEST THING I'M NOTICING OFF THE BAT IS THAT THIS TABLE HAS LOTS OF NULL QUANTITY AND SALES.  

--TRYING TO SEE IF THE BARCODE SALES ARE UNIFORMLY PRICED THEY ARE NOT
SELECT TOP 100 BARCODE, MIN(FINAL_SALE), MAX(FINAL_SALE) 
FROM T_TRANSACTIONS WHERE NULLIF(FINAL_SALE,'')  IS NOT NULL AND FINAL_QUANTITY = '1.0'
GROUP BY BARCODE 

--ARE THE PRICES UNIFORM BY BARCODE AND STORE?  --NO, THEY AREN'T
SELECT * FROM (
SELECT STORE_NAME, BARCODE, MIN(FINAL_SALE) AS MIN_SALE, MAX(FINAL_SALE) AS MAX_SALE
FROM T_TRANSACTIONS WHERE NULLIF(FINAL_SALE,'')  IS NOT NULL AND FINAL_QUANTITY = '1.0'
GROUP BY BARCODE, STORE_NAME) A WHERE MIN_SALE != MAX_SALE  --1133 RECORDS

--ADDING PURCHASE MONTH.  VOLUMES ARE STILL DIFFERENT FOR SAME ITEMS. 
SELECT * FROM (
SELECT STORE_NAME, SUBSTRING(PURCHASE_DATE,1,7) as MTH_ID,  BARCODE, MIN(FINAL_SALE) AS MIN_SALE, MAX(FINAL_SALE) AS MAX_SALE
FROM T_TRANSACTIONS WHERE NULLIF(FINAL_SALE,'')  IS NOT NULL AND FINAL_QUANTITY = '1.0'
GROUP BY BARCODE, SUBSTRING(PURCHASE_DATE,1,7), STORE_NAME) a WHERE MIN_SALE != MAX_SALE  --922 RECORDS

--LOOKED AT THE EXAMPLE BELOW AND REALIZED THIS TABLE HAS THE STORE NAME, BUT NOT THE LOCATION.  THAT IS PROBABLY SOME OF THE PRICE VARIATION THAT I'M SEEING
SELECT * FROM T_TRANSACTIONS WHERE BARCODE = '311111224057' and store_name = 'KROGER'

--ADDING STATE FROM USERS TABLE TO HOPEFULLY HELP TO PROXY THE LOCATION
SELECT * FROM (
SELECT STATE, STORE_NAME, SUBSTRING(PURCHASE_DATE,1,7) as MTH_ID,  BARCODE, MIN(FINAL_SALE) AS MIN_SALE, MAX(FINAL_SALE) AS MAX_SALE
FROM T_TRANSACTIONS B LEFT JOIN T_USERS C ON B.USER_ID = C.ID WHERE NULLIF(FINAL_SALE,'')  IS NOT NULL AND FINAL_QUANTITY = '1.0'
GROUP BY BARCODE, SUBSTRING(PURCHASE_DATE,1,7), STATE, STORE_NAME) a WHERE MIN_SALE != MAX_SALE;  --917 RECORDS (DIDN'T HELP MUCH)

--





Select
brand, sum(final_sale), sum(final_quantity) 
FROM transactions_ev a 
left join brand_d b ON a.barcode = b.barcode 
left join users_d c ON a.user_id = c.id
group by brand order by sum(final_sale) desc


select sum(case when isnull(brand,'') is null then 1 else 0 end), count(1) from t_products

Select brand, count(1) from t_products group by brand order by count(1) desc

Select * from t_products a where brand = '' and exists(select 1 from t_products where barcode = a.barcode and brand != '')

SELECT * FROM products_d a where brand != 'NOT SPECIFIED' and exists(select 1 from products_d where brand = 'NOT SPECIFIED' and barcode = a.barcode) and a.barcode > 0

Select * from (
Select barcode, min(brand) as min_bar, max(brand) as max_bar from t_products group by barcode ) a where min_bar != max_bar and min_bar = ''

Select * from t_transactions where barcode in('20031077','20733254','360054002','42208488','50426171')

SELECT * from (
select barcode, min(final_sale) as min_sale, max(final_sale) as max_sale, min(final_quantity) as min_q, max(final_quantity) as max_q, count(1) as cnt
from t_transactions group by barcode) a where min_sale != max_sale order by cnt desc

select * from t_transactions where barcode = '<NA>' order by store_name  --'78742223759'

select distinct store_name, barcode, final_sale, final_quantity from t_transactions where final_sale !='' and final_quantity != '' and barcode NOT IN('<NA>','-1')



select distinct barcode, final_sale, final_quantity from t_transactions where final_sale = '' or final_quantity = ''

Select * from t_transactions  --11028

select count(distinct barcode) from t_transactions where final_sale !='' and final_quantity != ''  --11028
--every single barcode has a quantity and sale amount assigned to it in the transaction table.  that should help fill in the blanks.


select * from t_transactions where final_quantity != '' order by final_quantity

---useful------------------------
select * from t_transactions where final_quantity != '' and cast(final_quantity as decimal(18,2)) != cast(cast(final_quantity as decimal(18,2)) as integer)

--LIFT CALCULATION FOR REQUEST-------------------------
SELECT total_users, last_year_total_users, 
cast((total_users - last_year_total_users) as decimal(18,2))/ last_year_total_users * 100 as growth_last_12_months
FROM(
SELECT 
    COUNT(DISTINCT CASE 
        WHEN CAST(t.created_date AS DATETIMEOFFSET) < d.dt_id 
        THEN t.id 
        ELSE NULL 
    END) AS last_year_total_users, 
    COUNT(DISTINCT t.id) AS total_users
FROM t_users t
CROSS JOIN (
    SELECT DATEADD(DAY, -365, MAX(CAST(created_date AS DATETIMEOFFSET))) AS dt_id 
    FROM t_users
) d) e;


Select brand, sum(FINAL_QUANTITY), sum(final_sale) from products_d a inner join transactions_ev b ON a.barcode = b.barcode
where a.category_2 like 'Dips%' group by brand order by sum(final_sale) desc

select sum(cast(final_sale as decimal(18,2))) from t_transactions where final_sale != ''


--very useful ------------
SELECT round(sum(final_sale_corrected),2), round(sum(final_sale_corrected2),2) FROM (
SELECT 
    barcode, final_quantity, store_name, 
    COALESCE(NULLIF(final_sale, ''), AVG(CAST(NULLIF(final_sale, '') AS DECIMAL(18,2))) OVER (PARTITION BY barcode, store_name, nullif(final_quantity,''), substring(purchase_date,1,7))) AS final_sale_corrected,
	COALESCE(NULLIF(final_sale, ''), AVG(CAST(NULLIF(final_sale, '') AS DECIMAL(18,2))) OVER (PARTITION BY barcode, store_name, nullif(final_quantity,''))) AS final_sale_corrected2,
	COALESCE(NULLIF(final_quantity, ''), AVG(CAST(NULLIF(final_quantity, '') AS DECIMAL(18,2))) OVER (PARTITION BY barcode, store_name, substring(purchase_date,1,7), nullif(final_sale,''))) AS final_quantity_corrected
FROM t_transactions) a -- WHERE final_sale_corrected != final_sale_corrected2;

select * from t_transactions


select * from t_transactions a where final_sale = ''

select * from t_transactions

Select distinct brand from t_products a inner join t_transactions b ON 
where category_2 like 'Dips%'

Select * from t_products where barcode = '40016679074.0'

Select * from t_transactions where barcode = '40016679074'



SELECT DATEADD(DAY, -365, MAX(CAST(created_date AS DATETIMEOFFSET))) AS dt_id FROM t_users;


select sum(final_sale) from transactions_ev where barcode = '78742223759'
select sum(convert(decimal(18,2), final_sale)) from t_transactions where barcode = '78742223759' and final_sale != ''

Select * from PRODUCTS_D where barcode = 78742223759

Select * from t_products where barcode = '78742371733'

SELECT * 
FROM users_d 
WHERE birth_date < DATEADD(YEAR, -100, GETDATE());

selECT DISTINCT GENDER FROM USERS_D


select * from transactions_ev


SELECT CASE WHEN YEAR(b.birth_date) BETWEEN 1901 AND 1924 THEN 'The Greatest Generation'
        WHEN YEAR(b.birth_date) BETWEEN 1925 AND 1945 THEN 'The Silent Generation'
        WHEN YEAR(b.birth_date) BETWEEN 1946 AND 1964 THEN 'Baby Boomers'
        WHEN YEAR(b.birth_date) BETWEEN 1965 AND 1980 THEN 'Generation X'
        WHEN YEAR(b.birth_date) BETWEEN 1981 AND 1996 THEN 'Millennials'
        WHEN YEAR(b.birth_date) BETWEEN 1997 AND 2012 THEN 'Generation Z'
        WHEN YEAR(b.birth_date) BETWEEN 2013 AND 2022 THEN 'Generation Alpha'
        WHEN YEAR(b.birth_date) >= 2025 THEN 'Generation Beta'
        ELSE 'Unknown Generation'
    END AS Generation,
    (SUM(a.final_sale) / SUM(SUM(a.final_sale)) OVER ()) * 100 AS Perc_of_Sales
FROM transactions_ev a JOIN users_d b ON a.user_id = b.id JOIN products_d c ON a.barcode = c.barcode
WHERE c.category_1 = 'Health & Wellness' AND a.final_sale IS NOT NULL
GROUP BY CASE WHEN YEAR(b.birth_date) BETWEEN 1901 AND 1924 THEN 'The Greatest Generation'
        WHEN YEAR(b.birth_date) BETWEEN 1925 AND 1945 THEN 'The Silent Generation'
        WHEN YEAR(b.birth_date) BETWEEN 1946 AND 1964 THEN 'Baby Boomers'
        WHEN YEAR(b.birth_date) BETWEEN 1965 AND 1980 THEN 'Generation X'
        WHEN YEAR(b.birth_date) BETWEEN 1981 AND 1996 THEN 'Millennials'
        WHEN YEAR(b.birth_date) BETWEEN 1997 AND 2012 THEN 'Generation Z'
        WHEN YEAR(b.birth_date) BETWEEN 2013 AND 2022 THEN 'Generation Alpha'
        WHEN YEAR(b.birth_date) >= 2025 THEN 'Generation Beta'
        ELSE 'Unknown Generation' END ORDER BY Perc_of_Sales DESC;


select * FROM transactions_ev a JOIN users_d b ON a.user_id = b.id where YEAR(b.birth_date) BETWEEN 1901 AND 1924

select * from users_d b where YEAR(b.birth_date) BETWEEN 1901 AND 1924 and exists(select 1 from transactions_ev where user_id = b.id)

SELECT 
    c.category_2,
	Brand,
    COUNT(a.receipt_id) AS transaction_count
FROM transactions_ev a
INNER JOIN products_d c ON a.barcode = c.barcode
WHERE c.category_2 = 'Dips & Salsa' AND a.final_sale IS NOT NULL and brand is not null
GROUP BY c.category_2, brand ORDER BY transaction_count DESC;

SELECT BARCODE, COUNT(1) FROM TRANSACTIONS_EV WHERE BARCODE < 0 GROUP BY BARCODE

Select * from products_d